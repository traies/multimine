\documentclass[spanish]{article}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{lmodern}
\usepackage[a4paper]{geometry}
\usepackage{babel}
\title{Trabajo práctico N. 1\\Sistemas Operativos - I.T.B.A}
\author{Marcantonio, Nicolás\\Raies,Tomás A.\\Saqués,M. Alejo}
\date{}
\begin{document}
\maketitle
\begin{abstract}
	En el presente informe, describiremos brevemente el problema que decidimos abordar, junto a aquellas decisiones de implementación que hemos tomado a los efectos de construir nuestro trabajo.
\end{abstract}
\newpage
\section{\textit{Buscaminas} multijugador }
\paragraph{} El objetivo del trabajo fue desarrollar una versión del conocido juego \textit{Buscaminas}, en la que potencialmente $N$ jugadores puedan participar concurrentemente. En estas condiciones, un jugador gana en el caso que $N-1$ jugadores pierdan, o bien cuando éste descubra todas las minas existentes en el tablero.
\paragraph{} Cada jugador no solo puede ver en su pantalla aquellas zonas descubiertas por él mismo, sino que verá también aquellas descubiertas por otros jugadores, cada una de ellas en un color distintivo. De esta forma, se ha logrado un efecto secundario en la dinámica del juego: la presión para tomar decisiones rápidas y correctas es mucho mayor que en el juego original. En el último, el tiempo corre como una medida para la superación personal. En nuestro juego, si no se es lo suficientemente rápido, se corre el riesgo de que otro gane antes que uno. 
\section{Esquema de funcionamiento}
\paragraph{} A continuación, describiremos los detalles del proceso de comunicación entre un cliente y el servidor, tras lo cual argumentaremos el porqué de las decisiones tomadas. 
\subsection{Explicación}
\paragraph{} Para que un cliente pueda comunicarse con el servidor y viceversa, hemos diseñado un esquema mediante el cual cada cliente posee dos \textit{agentes} para comunicarse con el servidor, uno que le proporciona los datos enviados por el mismo, y otro que le toma sus datos para remitirlos al servidor. 
\paragraph{} Inicialmente, el servidor abre su canal de comunicaciones y escucha $N$ conexiones entrantes en dicho canal. El cliente, al conocer la dirección en la cual el servidor está escuchando, procede a entablar una conexión con el mismo. El servidor, al recibir el intento de conexión por parte de un cliente, crea dos \textit{threads}: un \textit{Attender}, que correrá la rutina \verb|attend()|, y un \textit{Informer}, que ejecutará la rutina \verb|inform()|. Ambos \textit{threads} se comunican con el servidor maestro mediante \textit{pipes} que el último crea para tal propósito. Este mismo proceso sucede $\forall x,1 \leq x \leq N$, siendo $x$ el identificador de un cliente.
\paragraph{} Un \textit{Attender} es un \textit{thread} que espera mensajes del cliente a quien está atendiendo. Al recibir un mensaje, el \textit{Attender} lo redirecciona al servidor maestro, el cual está constantemente esperando actualizaciones de los \textit{Attenders} utilizando la \textit{syscall} \verb|select()| sobre los pipes en los cuales los mismos notifican al servidor. 
\paragraph{} Por otro lado, un \textit{Informer} es otro \textit{thread} encargado de enviarle a su cliente los mensajes que el servidor maestro tiene para el último. De esta forma, dicho \textit{Informer} está constantemente esperando actualizaciones del servidor maestro, utilizando la \textit{syscall} \verb|select()|. 
\paragraph{} Por su parte, para un momento dado, el cliente puede o bien haber realizado alguna acción, o bien estar esperando a que el servidor le envíe alguna actualización. En el primero de los casos, el cliente pedirá al servidor que actualice su contexto de juego en base a la casilla que solicitó descubrir. En este caso, el servidor le responderá con las casillas que descubrió tras realizar la acción, o bien informándole que la casilla que seleccionó contenía una bomba. Por otro lado, si el jugador en dicho momento no realizó ninguna acción, continuará escuchando mensajes del servidor. Por ejemplo, el servidor le informará a cada cliente de los descubrimientos de otros jugadores.
\paragraph{} Nótese que un cliente no conoce en absoluto que no se está comunicando directamente con el servidor, sino que dos \textit{threads} están actuando de mediadores. Él utiliza la conexión que estableció en un principio con el servidor maestro, y nunca advierte ninguna diferencia al respecto.
\subsubsection{Argumento}
\paragraph{} Al separar las tareas de recibir y enviar mensajes de un servidor para cada uno de los clientes conectados al mismo, creamos un escenario para un buen uso de una herramienta que provee el sistema operativo, la \textit{syscall} \verb|select()|. Es decir, estamos delegando en el sistema operativo la responsabilidad de detectar la existencia de nuevos mensajes no solamente del lado del servidor, sino también del lado del cliente. Otras alternativas, tales como crear un único \textit{thread} para atender a un cliente, hubieran significado para un cliente la necesidad de pedir cada un \textit{delta} de tiempo actualizaciones al servidor, el cual podría o no tenerlas. Con la estrategia utilizada, la llamada a \verb|select()| por parte del cliente evita tener que hacer \textit{busy waiting}, ya que una invocación exitosa de dicha \textit{syscall} confirma la existencia de un mensaje entrante.   
\section{Capa de comunicación}
\paragraph{} A continuación, enunciaremos aquellas características que merezcan observarse a propósito de la implementación de la capa de comunicaciones.
\paragraph{} Para evitar ser reiterativos, aclaramos que la capa de comunicaciones asume que quien desea conectarse conoce la dirección en donde debe hacerlo.
\subsection{Implementación con \textit{FIFOs}}
\paragraph{} En la implementación de la librería de comunicaciones con \textit{named pipes}, la llamada a \verb|mm_listen()| retorna un \verb|Listener| que contiene el \textit{file descriptor} correspondiente al \textit{FIFO} en el cual el invocador esperará conexiones entrantes. Esto último se realiza invocando la función \verb|mm_accept()|. La primera función recibe como argumento el \textit{path} en el cual dicho \textit{FIFO} debe crearse, donde, asimismo, otro proceso que quiera establecer una conexión con el primero deberá utilizar. La segunda, solicita que se le pase como argumento el \verb|Listener| que la primera ha creado.
\paragraph{} Al realizar la llamada a \verb|mm_connect()|, el proceso que desea conectarse abre el \textit{FIFO} pasado como argumento con permisos de escritura, y genera a su vez dos \textit{FIFOs} adicionales que serán utilizados en la nueva conexión: uno de ellos será en el que uno de los procesos escribe y el otro lee, mientras que en el otro \textit{FIFO}, los roles se encuentran invertidos. De esta forma, quien invoca a \verb|mm_connect()| le envía al proceso que está aceptando conexiones entrantes dichos \textit{FIFOs}, escribiendo sus direcciones en el \textit{named pipe} en el que el segundo está escuchando nuevas conexiones. De esta forma, cada nueva comunicación posee únicos \textit{file descriptors} de lectura y escritura, un par para cada uno de los dos procesos que participan de dicha conexión.
\subsection{Implementación con \textit{Sockets}}
\paragraph{} Hemos realizado implementaciones utilizando \textit{sockets} tanto \verb|AF_UNIX| como \verb|AF_INET|. Ambas implementaciones son similares en naturaleza, en el sentido que ambas utilizan las mismas llamadas al \textit{API} de \textit{sockets} de UNIX. La diferencia radica en que el \textit{binding} de la primera se realiza sobre un nombre en el \textit{filesystem}, mientras que la segunda se realiza sobre un puerto determinado.
\paragraph{} De esta forma, las llamadas a \verb|mm_listen()| y \verb|mm_connect()| en la implementación con \textit{sockets} \verb|AF_UNIX| requiren, tal como en el caso de la implementación con \textit{FIFOs}, que se les pase como argumento un \textit{path} determinado.
\paragraph{} Por otro lado, en el caso de la implementación con \textit{sockets} \verb|AF_INET|, los requerimientos son sensiblemente diferentes. Para el caso de \verb|mm_listen()|, la función espera que se le pase un \textit{string} conteniendo el número del puerto sobre el que se debe realizar el \textit{binding}. Por otro lado, la invocación a \verb|mm_connect()| espera un string que contenga tanto la dirección IP del \textit{host}, como así también el puerto en el cual se debe establecer la conexión. Por ejemplo, si un cliente corriendo en la misma máquina en la que se encuentra el servidor quiere conectarse al mismo, y conoce que el puerto en el que se encuentra el último es el $27456$, deberá pasar como argumento de \verb|mm_connect()| el \textit{string} \verb|localhost:27456| o, lo que es lo mismo, \verb|127.0.0.1:27456|. 
\end{document}
